# 스트림 활용

## 필터링

predicate로 필터링

stream().filter로 사용하는 filter 메서드는 인자로 predicate(boolean을 리턴하는 함수)를 받아서 predicate와 일치하는 모든 요소를 포함하는 스트림을 반환한다.

## 스트림 슬라이싱

특정 배열이 이미 정렬이 되어있는 상태라고 가정했을 때 필요한 요소보다 더 많이 탐색하는 연산은 불필요하다. 이를 위해 두가지 메소드 활용할 수 있다.

```
List<Dish> vegetarianMenu = menu.stream()
                                .filter(Dish.isVegetarian)
                                .collect(toList());
```

filter를 사용한 특정 스트림만을 반환하기 위한 코드

```
List<Dish> filteredMenu = specialMenu.stream()
                                .filter(dish -> dish.getCalories() < 320)
                                .collect(toList());
```

TakeWhile 활용하면 전체 요소에 대한 iteration이 필요하지 않다(정렬된 배열에 한해서)

```
List<Dish> filteredMenu = specialMenu.stream()
                                .takeWhile(dish -> dish.getCalories() < 320)
                                .collect(toList());
```

DropWhile 활용하면 나머지 요소를 다 가져갈 수 있다.

```
List<Dish> filteredMenu = specialMenu.stream()
                                .dropWhile(dish -> dish.getCalories() < 320)
                                .collect(toList());
```

### 스트림 축소

limit을 통하여 데이터 스트림의 필요한 부분만을 확인할 수 있다.

```
List<Dish> filteredMenu = specialMenu.stream()
                                .filter(dish -> dish.getCalories() < 320)
                                .limit(3)
                                .collect(toList());
```

### 요소 건너뛰기

stream의 skip 메서드를 활용하여 처음 n개 요소를 제외한 스트림을 반환하여 처리할 수 도 있다.


```
List<Dish> filteredMenu = specialMenu.stream()
                                .filter(dish -> dish.getCalories() < 320)
                                .skip(3)
                                .collect(toList());
```

## 매핑

### 스트림의 각 요소에 함수 적용하기

스트림은 함수를 인수로 받는 map 메서드를 지원한다. 인수로 제공된 함수는 각 요소에 적용되며 새로운 결과가 새로운 요소로 매핑된다. 이때 기존 요소가 수정된것이 아니라 새로운 형식의 자료구조에 매핑되는것이므로 매핑이라는 개념을 쓴다.

### 스트림의 평면화

```
[Hello, World]
words.stream()
           .map(word -> word.split(""))
           .distinct()
           .collect(toList())
```

위 코드엔 문제가 있는데 split의 결과로 배열이 나오고 배열안의 배열들을 대상으로 distinct 함수는 제대로 적용되지않는다.
이와같은 상황에서 flatMap이 사용된다.

#### map과 Array.stream() 활용

```
String[] arrayOfWords = { "Goodbye", "World"}
Stream<String> streamOfWords = Arrays.stream(arrayOfWords);
List<String> uniqueCharacters = words
                                    .stream()
                                    .map(word -> word.split(""))
                                    .map(Arrays::stream)
                                    .distinct()
                                    .collect(toList());

```

해당 코드는 스트림으로 이루어진 리스트를 반환하기 때문에 목적에 맞지 않는다
ex. List<Stream<String>>

#### flatMap 사용

```
List<String> uniqueCharacters = words
                                    .stream()
                                    .map(word -> word.split(""))
                                    .flatMap(Arrays::stream)
                                    .distinct()
                                    .collect(toList());
```

flatMap은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑한다. 즉 평면화된 하나의 스트림을 반환한다.

## 검색과 매칭

### predicate가 적어도 한 요소와 일치하는지 확인


```
if(menu.stream().anyMatch(Dish::isVegetarian)) {
    //
}
```
anyMatch는 boolean을 반환

### predicate가 모든 요소와 일치하는지 검사

```
boolean isHealthy = menu.stream().allMatch(dish -> dish.getCalories() < 1000>);
```

### predicate가 모든 요소와 일치하지 않는지 검사

```
boolean isHealthy = menu.stream().noneMatch(dish -> dish.getCalories() < 1000>);
```

anyMatch, allMatch, noneMatch 메서드는 스트림 쇼트서킷 기법, 즉 자바의 &&, ||와 같은 연산을 활용한다.

and 연산으로 연결된 커다란 불리언 표현식을 평가한다고 가정했을 대 표현식에서 하나라도 거짓이라는 결과가 나오면 나머지 표현식의 결과와 상관없이 전체 결과도 거짓이 된다. 이러한 상황을 쇼트서킷이라고 부른다.

### 요소검색

findAny를 통하여 현재 스트림에서 임의의 요소를 반환한다. 스트림 파이프라인은 내부적으로 단일 과정으로 실행할 수 있도록 최적화 되기 때문에 이러한 쇼트서킷을 이용하여 결과를 찾는 즉시 실행을 종료한다.

```
Optional<Dish> dish = menu.stream()
                            .filter(Dish:isVegetarian)
                            .findAny();
```

#### Optional이란?

Optional 클래스는 값의 존재나 부재 여부를 표현하는 컨테이너 클래스다. 위의 예제에서 findAny는 아무 요소도 반환하지 않을 수 있고 이는 npe를 일으킬 수 있다. 이와 같은 부분을 처리하기 위해 Optional을 사용한다.

- isPresent는 Optional이 값을 포함하면 true, 아니면 false를 반환한다.
- ifPresent(Consumer <T> block)는 값이 있으면 주어진 블록을 실행한다.
- T get()은 값이 존재하면 값을 반환, 값이 없으면 NoSuchElementException을 일으킨다.
- T orElse(T other)는 값이 있으면 값을 반환, 없으면 기본값(other)을 반환한다.

### 첫번째 요소 찾기

```
List<Integer> someNumbers = Arrays.asList(1,2,3,4,5);
Optional<Integer> firstSquareDivisibleByThree = someNumbers.stream()
                                                    .map(n -> n *n )
                                                    .filter(n -> n % 3 == 0)
                                                    .findFirst(); // 9
```

findFirst, findAny가 필요한 이유는?

병렬성 때문이다. 병렬 실행에서는 첫번째 요소를 찾기 어렵다. 따라서 요소의 반환 순서가 상관없다면 병렬 스트림에서는 제약이 적은 findAny를 사용한다.

## 리듀싱

'메뉴의 모든 칼로리의 합계를 구하라', '메뉴에서 칼로리가 가장 높은 요리는?' 같은 스트림 요소를 조합해서 더 복잡한 질의를 표현 할 때 reduce 연산을 활용한다.
함수형 프로그래밍 언어 용어로는 폴드라고도 한다. 스트림 요소에 대해 이터레이션이 발생하면서 특정 값을 도출해내는 행위가 종이를 작은 조각이 될 때까지 반복해서 접는 것과 비슷하다는 의미에서.

### 요소의 합

```
// 초기값 있을 때
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
int product = numbers.stream().reduce(1, (a, b) -> a * b);

// 초기값 없을 때
// stream에 아무 요소도 없다면 초기값이 없으므로 합계까 없음을 가라킬 수 있는 Optional이 반환된다.
Optional<Integer> sum = numbers.stream().reduce((a, b) -> (a + b));

```

### 최댓값과 최솟값

```
Optional<Integer> max = numbers.stream().reduce(Integer::max);
```